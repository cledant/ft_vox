#ifndef FT_VOX_NOISEUTILS_HPP
#define FT_VOX_NOISEUTILS_HPP

#include <array>

#include "glm/glm.hpp"

#include "PerlinNoise.hpp"

static constexpr glm::u8vec3 const MAP_COLOR_BLUE = glm::u8vec3(0, 0, 200);
static constexpr glm::u8vec3 const MAP_COLOR_BROWN = glm::u8vec3(110, 70, 40);
static constexpr glm::u8vec3 const MAP_COLOR_GREEN = glm::u8vec3(0, 200, 0);
static constexpr glm::u8vec3 const MAP_COLOR_YELLOW = glm::u8vec3(200, 200, 0);
static constexpr glm::u8vec3 const MAP_COLOR_WHITE = glm::u8vec3(255, 255, 255);
static constexpr glm::u8vec3 const MAP_COLOR_BLACK = glm::u8vec3(0, 0, 0);
static constexpr glm::u8vec3 const MAP_COLOR_RED = glm::u8vec3(255, 0, 0);

template<typename Iterator, typename T>
constexpr T
sum_array(Iterator begin, Iterator end, T init_val)
{
    for (; begin != end; ++begin) {
        init_val = std::move(init_val) + *begin;
    }
    return (init_val);
}

[[nodiscard]] glm::vec2 getElevationTemperature(glm::vec2 const &coord,
                                                PerlinNoise const &pn);
[[nodiscard]] glm::vec2 getCaveLimits(glm::vec2 const &coord,
                                      PerlinNoise const &pn);
void generateMap(glm::ivec2 const &size, uint32_t seed, void *buffer);
/** \brief Helper to remap value generated by 3D perlin noise
 * \param A 3D vector
 * \param A perlin noise generator
 * \return value between [0; 1]
 */
[[nodiscard]] float noise3dRemapped(glm::vec3 const &vec,
                                    PerlinNoise const &pn);
/** \brief Helper to remap value generated by 2D perlin noise
 * \param A 2D vector
 * \param A perlin noise generator
 * \return value between [0; 1]
 */
[[nodiscard]] float noise2dRemapped(glm::vec2 const &vec,
                                    PerlinNoise const &pn);

#endif // FT_VOX_NOISEUTILS_HPP